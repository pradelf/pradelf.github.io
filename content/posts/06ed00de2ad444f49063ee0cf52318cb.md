---
title: WebSocket
slug: 06ed00de2ad444f49063ee0cf52318cb
tags: []
date: 2023-04-12T22:20:20.581Z
---

# WebSocket

WebSocket
Pour pouvoir utiliser WebSocket, vous devez avoir un navigateur Web à jour :

Internet Explorer à partir de la version 10
Firefox à partir de la version 6
Chrome à partir de la version 14
Opera à partir de la version 12.10
Safari à partir de la version 6
Sur la page serveur, le WebSocket peut être mis en place grâce aux langages de programmation suivants :

Node.js
Socket.IO
WebSocket-Node
ws
Java
Jetty
Ruby
EventMachine
Python
pyWebSocket
Tornado
Erlang
Shirasu
C++
libWebSockets
.NET
SuperWebSocket
En résumé
Le protocole WebSocket est une technologie qui s’inscrit dans le cadre du développement du HTML5 : une tentative de rendre le Web plus rapide, plus dynamique et plus sûr. Ce protocole performant permet l’utilisation d’applications Web modernes qui fonctionnent beaucoup plus rapidement que celles auxquelles nous sommes habitués dans le cadre de communications HTTP traditionnelles. Cela ne signifie cependant pas qu’il faut se débarrasser de l’ancien protocole. Malgré le WebSocket, HTTP demeure un standard majeur de la communication Internet.

## Comprendre la puissance des WebSockets

Dino Esposito (Microsoft)
<https://learn.microsoft.com/fr-fr/archive/msdn-magazine/2012/may/cutting-edge-understanding-the-power-of-websockets>

Dino EspositoÀ l'heure actuelle, le World Wide Web n'est pas conçu pour être un moyen de communication en temps réel. Les applications Web donnent une impression de continuité grâce aux solutions d'interrogation classiques implémentées via AJAX ou peut-être aux requêtes à interrogation longue, alors qu'elles sont en fait implémentées par des bibliothèques ad hoc telles que SignalR et Comet. Pour les besoins de la plupart des applications, l'interrogation est une bonne solution, bien qu'elle risque de pâtir d'une latence client vers serveur et serveur vers client. Dans cet article, je vais explorer une nouvelle alternative nommée WebSocket.
L'intégration croissante entre les applications Web et mobiles avec les réseaux sociaux réduit le seuil de délai tolérable dans l'interaction client/serveur. Lorsque vous mettez à jour votre statut Facebook, vous voulez que cette information soit disponible immédiatement pour vos amis. De la même manière, lorsque quelqu'un apprécie l'une de vos publications, vous voulez être averti instantanément. À l'heure actuelle, toutes ces fonctionnalités sont une réalité et c'est simplement l'une des raisons de l'adoption mondiale de Facebook ou de l'explosion du phénomène des réseaux sociaux. Cela explique pourquoi il existe une telle demande des développeurs pour des solutions et des outils d'implémentation de la communication via le Web en temps réel.
Le protocole HTTP ne permet pas d'atteindre une connectivité sans temps mort entre les clients Web et les serveurs. En revanche, c'est exactement ce qu'apporte le protocole WebSocket. Il existe actuellement une norme IETF (Internet Engineering Task Force) pour le protocole WebSocket. Pour plus d'informations sur ce sujet, accédez à bit.ly/va6qSS. Une API standard permettant d'implémenter le protocole est en cours de formalisation par le World Wide Web Consortium (W3C) afin que les navigateurs puissent le prendre en charge (reportez-vous à bit.ly/h1IsjB). Les spécifications ont aujourd'hui le statut « Recommandation candidat »
Le protocole WebSocket
Le nouveau protocole WebSocket a pour objectif de dépasser une limite structurelle du protocole HTTP selon laquelle le fait que les applications Web hébergées dans les navigateurs restent connectées au serveur via une connexion permanente est inefficace. Le protocole WebSocket permet une communication bidirectionnelle entre les applications Web et les serveurs Web via un seul socket TCP. En d'autres termes, le protocole rend possible la connexion permanente d'une application Web hébergée dans un navigateur avec un point de terminaison Web, tout en entraînant des coûts minimum, tels que la pression sur le serveur, la mémoire et l'utilisation des ressources. Le résultat final est que les données et les notifications peuvent passer d'un navigateur et d'un serveur Web à l'autre sans aucun retard et sans aucune nécessité d'organiser des demandes supplémentaires. Aussi pompeux que cela puisse sembler, le protocole WebSocket ouvre tout un nouveau monde de possibilités pour les développeurs et relègue dans le passé les infrastructures et les astuces reposant sur l'interrogation. En fait, ce n'est pas tout à fait le cas.
Utilisation du protocole WebSocket aujourd'hui
La prise en charge du protocole WebSocket par les navigateurs augmentera rapidement mais, selon toute évidence, seules les dernières versions de navigateurs le prendront en charge. Les utilisateurs qui n'ont pas pour habitude de mettre à niveau leur navigateur régulièrement (ou qui ne sont pas autorisés à le mettre à niveau en raison de politiques d'entreprise strictes) seront laissés pour compte.
Cela signifie que les développeurs ne peuvent pas simplement abandonner le code reposant sur l'interrogation AJAX ou sur les solutions d'interrogation longue. À cet égard, il est pertinent de mentionner que SignalR, la future infrastructure Microsoft pour un temps mort nul entre les navigateurs et les serveurs Web, effectue un travail magnifique d'abstraction d'une connexion permanente, de passage automatique au protocole WebSocket lorsqu'il est pris en charge et d'utilisation des interrogations longues dans tous les autres cas. J'ai abordé SignalR dans des articles récents et je vous invite à nouveau à le tester dès que vous le pourrez si cela n'a pas encore été fait. SignalR a toutes les qualités pour être une bibliothèque gagnante et un outil pour chaque développeur et toutes les applications Web.
Par qui WebSocket est-il pris en charge aujourd'hui ?
La figure 1 présente un résumé rapide de la prise en charge du protocole WebSocket par les navigateurs les plus populaires à l'heure actuelle.
Figure 1 Prise en charge du protocole WebSocket par les navigateurs
Navigateur	Prise en charge de WebSocket
Internet Explorer	Le protocole WebSocket sera pris en charge dans Internet Explorer 10. Les applications de type Metro écrites à l'aide de JavaScript et HTML5 prendront également en charge WebSocket.
Firefox	WebSocket est pris en charge depuis la version 6 du navigateur lancée mi-2011. Une prise en charge très précoce était proposée dans la version 4, mais elle a été abandonnée dans la version 5.
Chrome	WebSocket est pris en charge depuis la version 14, lancée en septembre 2011.
Opera	La prise en charge de WebSocket a été retirée dans la version 11.
Safari	Prend en charge une version antérieure du protocole WebSocket.
À l'exception de Firefox, vous pouvez vérifier par programme si WebSocket est pris en charge en examinant l'objet window\.WebSocket. Pour Firefox, vous devez actuellement vérifier l'objet MozWebSocket. Il est important de noter que la plupart des fonctionnalités liées à HTML5 peuvent être vérifiées dans les navigateurs à l'aide d'une bibliothèque spécialisée, telle que Modernizr (modernizr.com). Voici plus particulièrement le code JavaScript que vous devez écrire si vous avez lié la bibliothèque Modernizr à votre page :
JavaScript

Copier
if (Modernizr.websockets)
{
...
}
Modernizr est probablement un choix excellent aujourd'hui si vous souhaitez commencer à utiliser l'implémentation WebSocket. En effet, cette bibliothèque propose des polyfills, un code qui entre automatiquement en action si une fonctionnalité particulière n'est pas prise en charge sur le navigateur actuel.
Finalement, le protocole WebSocket est une fonctionnalité extrêmement convaincante avec, à l'heure actuelle, une prise en charge non uniforme d'un fournisseur à l'autre. Toutefois, Microsoft prend largement en charge WebSocket via le futur Internet Explorer 10, ainsi qu'IIS, ASP.NET, Windows Communication Foundation (WCF) et Windows Runtime (WinRT). Notez cependant qu'il n'existe encore aucune API standard. La prise en charge précoce est donc un signe d'intérêt formidable. À l'heure actuelle, la meilleure solution consiste à utiliser WebSocket via une couche d'abstraction. Dans cette optique, Modernizr est une option possible si vous souhaitez rester proche des bases et écrire votre propre code permettant d'ouvrir et de fermer WebSocket. SignalR représente une option plus appropriée si vous recherchez une infrastructure connectant en toute transparence un navigateur et un point de terminaison Web de façon permanente, sans fioritures et sans avoir besoin de connaître de nombreux détails sous-jacents.
Le protocole WebSocket plus en détails
Dans le cadre du protocole WebSocket pour la communication bidirectionnelle, l'application serveur et l'application cliente doivent connaître les détails du protocole. Cela signifie que vous avez besoin d'une page Web compatible WebSocket qui appelle un point de terminaison compatible WebSocket.
Une interaction WebSocket commence par un établissement de liaison dans lequel les deux parties (le navigateur et le serveur) confirment mutuellement leur intention de communiquer via une connexion permanente. Ensuite, un groupe de paquets de messages est envoyé via TCP dans les deux sens. La figure 2 représente le fonctionnement du protocole WebSocket.
The WebSocket Protocol Schema
Figure 2 Le schéma du protocole WebSocket
Outre les détails figurant à la figure 2, notez que lorsque la connexion est fermée, les deux points de terminaison échangent une trame de fermeture afin de fermer proprement la connexion. La demande d'établissement de liaison initiale est composée d'une requête HTTP ordinaire envoyée par le client au serveur Web. La requête est un HTTP GET configuré comme une demande de mise à niveau :
XML

Copier
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: <http://example.com>
Avec HTTP, une requête du client avec l'en-tête Upgrade indique l'intention du client de demander à ce que le serveur passe à un autre protocole. Avec le protocole WebSocket, la demande de mise à niveau effectuée au serveur contient une clé unique que le serveur retournera altérée comme preuve qu'il a accepté la demande de mise à niveau. Il s'agit d'une démonstration pratique permettant de prouver que le serveur comprend le protocole WebSocket. Voici un exemple de réponse à une demande d'établissement de liaison :
XML

Copier
HTTP/1.1 101 WebSocket Protocol Handshake
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Le code de statut de réussite est toujours 101. Tout autre code de statut sera interprété comme un refus de mettre à niveau vers le protocole WebSocket. Le serveur concatène la clé reçue avec une chaîne GUID fixe et il calcule le hachage à partir de la chaîne obtenue. La valeur de hachage est ensuite codée en Base64 et retournée au client via l'en-tête Sec-WebSocket-Accept.
Le client peut également envoyer d'autres en-têtes tels que Sec-WebSocket-Protocol afin d'indiquer quels sous-protocoles il est prêt à utiliser. Un sous-protocole est un protocole au niveau de l'application qui est créé sur le protocole WebSocket de base. Si le serveur comprend certains des sous-protocoles suggérés, il en choisit un et renvoie son nom au client via le même en-tête.
À la suite de l'établissement de liaison, le client et le serveur peuvent envoyer des messages librement via le protocole WebSocket. La charge commence par un opcode qui indique l'opération effectuée. L'un de ces opcodes, à savoir 0x8, indique une requête pour fermer la session. Notez que les messages WebSocket sont asynchrones et qu'une demande d'envoi ne recevra donc pas nécessairement une réponse immédiate, comme avec HTTP. Avec le protocole WebSocket, il est conseillé de réfléchir en termes de messages généraux allant du client vers le serveur, ou inversement, et d'oublier le modèle classique demande/réponse de HTTP.
L'URL type d'un point de terminaison WebSocket a la forme suivante :
JavaScript

Copier
var myWebSocket =
new WebSocket("ws\://[www.websocket.org](http://www.websocket.org)");
Vous utilisez le préfixe de protocole wss si vous souhaitez aller sur une connexion de socket sécurisée (les connexions sécurisées sont généralement plus réussies lorsque des intermédiaires sont présents). En dernier lieu, le protocole WebSocket reconnaît et traite le problème de la communication cross-origin. Un client WebSocket autorise généralement, mais pas toujours, l'envoi de requêtes vers des points de terminaison situés sur n'importe quel domaine. Mais c'est le serveur WebSocket qui décide d'accepter ou de refuser la demande d'établissement de liaison.
L'API WebSocket plus en détails
Comme nous l'avons déjà mentionné, le W3C normalise actuellement une API pour le protocole WebSocket et les navigateurs rattrapent leur retard avec les différentes versions préliminaires à mesure qu'elles deviennent disponibles. Vous devez être conscient que tout code opérationnel aujourd'hui ne fonctionnera pas nécessairement sur tous les navigateurs et qu'il n'y a surtout aucune garantie qu'il fonctionnera sur le même navigateur lorsqu'une nouvelle version sera lancée. Dans tous les cas, une fois que vous disposez d'un code WebSocket fonctionnel, vous êtes plus ou moins tranquille dans la mesure où les modifications susceptibles d'être demandées à l'avenir seront très probablement mineures.
Si vous souhaitez expérimenter le protocole WebSocket, rendez-vous sur le site websocket.org avec un navigateur prenant en charge le protocole. Vous pouvez, par exemple, utiliser une version préliminaire d'Internet Explorer 10 ou une version récente de Google Chrome. La figure 3 illustre l'établissement de communication suivi par Fiddler.
Real Handshaking Between Browser and Server
Figure 3 Un véritable établissement de communication entre le navigateur et le serveur
Il n'est pas surprenant que la version actuelle de Fiddler (version 2.3.x) ne capture que le trafic HTTP. Toutefois, une nouvelle version de Fiddler qui prend en charge le trafic WebSocket est actuellement en bêta.
L'API WebSocket est relativement simple. Côté navigateur, vous devez créer une instance de la classe de navigateur WebSocket. Cette classe expose un certain nombre d'événements intéressants pour lesquels il est souhaitable d'avoir les gestionnaires appropriés :
JavaScript

Copier
var wsUri = " ws\://echo.websocket.org/";
websocket = new WebSocket(wsUri);
websocket.onopen = function(evt) { onOpen(evt) };
websocket.onmessage = function(evt) { onMessage(evt) };
websocket.onclose = function(evt) { onClose(evt) };
websocket.onerror = function(evt) { onError(evt) };
L'événement onopen est déclenché lorsque la connexion est établie. L'événement onmessage est déclenché lorsque le client reçoit un message du serveur. L'événement onclose est déclenché lorsque la connexion a été fermée. Et en dernier lieu, onerror est déclenché dès qu'une erreur se produit.
Pour envoyer un message au serveur, vous n'avez qu'à appeler la méthode send, comme illustré ici :
JavaScript

Copier
var message = "Cutting Edge test: " +
new Date().toString();
websocket.send(message);
La figure 4 illustre un exemple de page correspondant à une adaptation de l'exemple « echo » qui se trouve sur le site Web websocket.org. Dans cet exemple, le serveur se contente de renvoyer le message reçu au client.
The WebSocket Protocol in Action
Figure 4 Le protocole WebSocket en action
Si vous êtes intéressé par la programmation WebSocket pour Internet Explorer 10, consultez bit.ly/GNYWFh.
Le côté serveur de WebSocket
Dans cet article, je me suis essentiellement concentré sur le côté client du protocole WebSocket. Vous devez cependant savoir que pour utiliser un client WebSocket, vous avez besoin d'un serveur compatible WebSocket qui comprenne les demandes et puisse répondre de façon appropriée. Des infrastructures permettant de créer un serveur WebSocket ont commencé à faire leur apparition. Par exemple, vous pouvez essayer Socket.IO pour Java et Node.js (socket.io). Si vous recherchez des informations sur le Microsoft .NET Framework, lisez la page « Web Socket Server » du site The Code Project, sur bit.ly/lc0rjt. En outre, la prise en charge de serveur Microsoft pour WebSocket est disponible dans IIS, ASP.NET et WCF. Vous pouvez consulter la vidéo sur Channel 9, « Building Real-Time Web Apps with WebSockets Using IIS, ASP.NET and WCF » pour en savoir plus (bit.ly/rnYaw5).
Pain tranché, eau chaude et WebSocket
Comme beaucoup l'ont dit, le protocole WebSocket est l'invention la plus utile depuis le pain tranché et l'eau chaude. Une fois que vous avez compris le fonctionnement de ce protocole, vous vous demandez simplement comment le monde du logiciel aurait pu se développer sans lui. WebSocket est utile dans un certain nombre d'applications, bien qu'il ne puisse pas être utilisé avec n'importe quelle application. Toute application dans laquelle la messagerie instantanée est essentielle constitue un scénario potentiel dans le cadre duquel vous pouvez sérieusement envisager de créer un serveur WebSocket et un certain nombre de clients, Web, mobiles, voire de bureau. Les applications de jeux et de flux live sont d'autres domaines du secteur qui bénéficieront énormément du protocole WebSocket. Oui, WebSocket est sans aucun doute la meilleure invention après l'eau chaude !
Dino Espositoest l'auteur de « Programming Microsoft ASP.NET 4 » (Microsoft Press, 2011) et de « Programming Microsoft ASP.NET MVC 3 » (Microsoft Press, 2010). Il a également coécrit « Microsoft .NET: Architecting Applications for the Enterprise » (Microsoft Press, 2008). Basé en Italie, Dino Esposito participe régulièrement aux différentes manifestations du domaine organisées aux quatre coins du monde. Vous pouvez le suivre sur Twitter à l'adresse twitter.com/despos.
Merci aux experts techniques suivants d'avoir relu cet article :  Levi Broderick et Brian Raymor

## sniff wsh

Run this script in Chrome's console

You can modify and send the frames to a server via ajax

(function() {
WebSocket.prototype.\_send = WebSocket.prototype.send;
WebSocket.prototype.send = function(data) {
this.\_send(data);
this.addEventListener('message', function(msg) {
console.log('>> ' + msg.data);
}, false);
this.send = function(data) {
this.\_send(data);
console.log("<< " + data);
};
}
})();
<https://stackoverflow.com/questions/35567399/how-do-i-sniff-wss-websocket-traffic-that-is-handled-in-a-swf>

<https://www.baeldung.com/debug-websockets>

<https://wiki.wireshark.org/WebSocket>
